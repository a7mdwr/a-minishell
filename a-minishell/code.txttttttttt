==> makefile <==
	$(CC) $(CFLAGS) $(OBJS) -o $(NAME) -L ./libft -lft -lreadline -I.brew/opt/readline/include -L/opt/vagrant/embedded/lib -lreadline

clean:
	cd libft && make fclean
	rm -f $(OBJS)

fclean: clean
	rm -f $(NAME)

re: fclean all

==> parsing/cmds.c <==
#include "../minishell.h"

void	remove_substr(char *s, unsigned int start, size_t len)
{
	size_t	i;
	size_t	j;

	i = 0;
	j = 0;
	while (s[i])
	{
		if (i < start || i >= len)
		{
			s[j] = s[i];
			j++;
		}
		i++;
	}
	s[j] = '\0';
}

void	store_the_file_name(char *str, char **file_name, int i, t_variables *v)
{
	int			start;
	t_variables	qv;

	start = i;
	qv.i = i;
	qv.in_quotes = 0;
	qv.in_d_quotes = 0;
	while (str[i])
	{
		qv.i = i;
		quotes_check(&str, &qv);
		if ((str[i] == ' ' || str[i] == '\t') && \
!qv.in_quotes && !qv.in_d_quotes)
			break ;
		i++;
	}
	v->i = i;
	(*file_name) = ft_substr(str, start, i - start);
}

void	files_fillings(t_shell *pipe, t_cmds *cmds, t_variables *v)
{
	v->start = v->char_i - 1;
	if (pipe->cmds[v->cmd_i][v->char_i + 1] == '>' \
|| pipe->cmds[v->cmd_i][v->char_i + 1] == '<')
	{
		if (pipe->cmds[v->cmd_i][v->char_i + 1] == '>')
			cmds[v->cmd_i].outs[v->xy].flag = APPEND;
		else if (pipe->cmds[v->cmd_i][v->char_i + 1] == '<')
			cmds[v->cmd_i].outs[v->xy].flag = HERE_DOC;
		v->char_i = v->char_i + 2;
	}
	else if (pipe->cmds[v->cmd_i][v->char_i] == '>')
	{
		cmds[v->cmd_i].outs[v->xy].flag = OUT_FILE;
		v->char_i++;
	}
	else if (pipe->cmds[v->cmd_i][v->char_i] == '<')
	{
		cmds[v->cmd_i].outs[v->xy].flag = IN_FILE;
		v->char_i++;
	}
}

void	utils_saving(t_shell *pipe, t_cmds *cmds, t_variables *v)
{
	v->xy = 0;
	v->char_i = -1;
	while (pipe->cmds[v->cmd_i][++v->char_i])
	{
		quotes_check(&pipe->cmds[v->cmd_i], v);
		if ((pipe->cmds[v->cmd_i][v->char_i] == '>' || \
pipe->cmds[v->cmd_i][v->char_i] == '<') && !v->quote_char)
		{
			files_fillings(pipe, cmds, v);
			store_the_file_name(pipe->cmds[v->cmd_i], \
&cmds[v->cmd_i].outs[v->xy].file_name, v->char_i + 1, v);
			clean_quotes(cmds[v->cmd_i].outs[v->xy].file_name);
			remove_substr(pipe->cmds[v->cmd_i], v->start, v->i);
			v->char_i = v->start - 1;
			printf("file name : %s\n", cmds[v->cmd_i].outs[v->xy].file_name);
			printf("flag	  : %d\n", cmds[v->cmd_i].outs[v->xy].flag);
			v->xy++;
		}
	}
}

void	init_commands(t_shell *pipe, t_cmds **tmp)
{
	t_cmds		*cmds;
	t_variables	v;

	v.start = 0;
	v.quote_char = 0;
	v.arg_i = 0;
	v.cmd_i = -1;
	v.char_i = 0;
	*tmp = malloc(sizeof(t_cmds) * pipe->cmd_len);
	cmds = *tmp;
	cmds->red_len = 0;
	while (++v.cmd_i < pipe->cmd_len)
	{
		cmds[v.cmd_i].red_len = num_of_redirects(pipe->cmds[v.cmd_i]);
		if (cmds[v.cmd_i].red_len)
			cmds[v.cmd_i].outs = malloc(sizeof(t_redirect) * \
cmds[v.cmd_i].red_len);
		utils_saving(pipe, cmds, &v);
		cmds[v.cmd_i].cmds = ft_split(pipe->cmds[v.cmd_i], ' ');
		v.arg_i = 0;
		while (cmds[v.cmd_i].cmds[v.arg_i])
			clean_quotes(cmds[v.cmd_i].cmds[v.arg_i++]);
		v.arg_i = 0;
		while (cmds[v.cmd_i].cmds[v.arg_i])
			puts(cmds[v.cmd_i].cmds[v.arg_i++]);
	}
}

==> parsing/dollar.c <==
#include "../minishell.h"

char	*storing(char *str, int start, int len, char *replace)
{
	char	*new_str;
	int		i;
	int		j;

	if (!str || start + len > (int)ft_strlen(str))
		return (NULL);
	new_str = malloc(sizeof(char) * \
(ft_strlen(str) - len + ft_strlen(replace) + 1));
	if (!new_str)
		return (NULL);
	i = 0;
	j = 0;
	while (i < start)
		new_str[j++] = str[i++];
	while (*replace)
		new_str[j++] = *replace++;
	while (str[i + len])
	{
		new_str[j] = str[i + len];
		i++;
		j++;
	}
	new_str[j] = '\0';
	free(str);
	return (new_str);
}

int	expand(char **str, char *expanded, t_variables *v)
{
	expanded = NULL;
	v->i++;
	if ((*str)[v->i] == '?' && v->i == 1 && (*str)[v->i - 1] == '$')
	{
		expanded = ft_itoa(g_exit_code);
		*str = storing(*str, v->i - 1, 2, expanded);
		v->i += ft_strlen(expanded) - 2;
		free(expanded);
		return (1);
	}
	if (!ft_isalpha((*str)[v->i]) && (*str)[v->i] != '_')
		return (1);
	v->len = 0;
	while (ft_isalnum((*str)[v->i]) || (*str)[v->i] == '_')
	{
		v->len++;
		v->i++;
	}
	return (0);
}

void	generate_strings_helper(char **str, char *expanded, t_variables *v)
{
	char	*joined;
	char	*joined2;

	if (!v->in_d_quotes)
	{
		joined = ft_strjoin(expanded, "\"");
		joined2 = ft_strjoin("\"", joined);
		*str = storing(*str, v->i - v->len - 1, v->len + 1, joined2);
		v->i += ft_strlen(expanded) - v->len - 1;
		free(joined2);
		free(joined);
	}
	else
	{
		*str = storing(*str, v->i - v->len - 1, v->len + 1, expanded);
		v->i += ft_strlen(expanded) - v->len - 1;
	}
}

int	generate_string(char **str, char **tmp, t_variables *v, t_shell *pipe)
{
	char	*expanded;

	expanded = NULL;
	if (*tmp)
	{
		expanded = my_getenv(*tmp, pipe);
		if (expanded)
		{
			generate_strings_helper(str, expanded, v);
		}
		else if (!expanded)
		{
			*str = storing(*str, v->i - v->len - 1, v->len + 1, "");
			v->i -= v->len + 1;
		}
		free(*tmp);
		return (1);
	}
	return (0);
}

void	dollar_expansion(char **str, t_shell *pipe)
{
	t_variables	v;
	char		*tmp;
	char		*expanded;

	v.len = 0;
	expanded = NULL;
	v.i = 0;
	v.in_d_quotes = 0;
	v.in_quotes = 0;
	while ((*str)[v.i])
	{
		quotes_check(str, &v);
		if ((*str)[v.i] == '$' && !v.in_quotes && (*str)[v.i + 1])
		{
			if (expand(str, expanded, &v))
				continue ;
			tmp = ft_substr(*str, v.i - v.len, v.len);
			if (generate_string(str, &tmp, &v, pipe))
				continue ;
		}
		v.i++;
	}
}

==> parsing/env.c <==
#include "../minishell.h"

void	copy_env(t_shell *s, char **env)
{
	int	i;

	i = 0;
	s->environment = NULL;
	while (env[i])
	{
		ft_lstadd_back(&s->environment, ft_lstnew(env[i]));
		i++;
	}
	s->environment_num = i;
}

char	*my_getenv(const char *name, t_shell *pipe)
{
	char	*value;
	size_t	name_len;
	t_list	*env;
	char	*key;

	value = NULL;
	name_len = ft_strlen(name);
	env = pipe->environment;
	while (env != NULL)
	{
		key = (char *) env->content;
		if (ft_strncmp(key, name, name_len) == 0 && key[name_len] == '=')
		{
			value = key + name_len + 1;
			break ;
		}
		env = env->next;
	}
	return (value);
}

==> parsing/parser.c <==
#include "../minishell.h"

int	g_exit_code = 0;

int	parsing(t_shell *pipe, t_cmds *cmds, char *input)
{
	if (spaces(input))
		return (1);
	if (!redirections_parse(input))
	{
		printf("syntax error, unexpected redirection token\n");
		add_history(input);
		g_exit_code = 258;
		return (1);
	}
	else if (!handle_pipes(pipe, input, cmds))
	{
		printf("Error\n");
		add_history(input);
		g_exit_code = 258;
		return (1);
	}
	return (0);
}

==> parsing/pipes.c <==

#include "../minishell.h"


static int pipe_from_back(char *input)
{
    int	len;
	int	i;

	len = ft_strlen(input);
	if (!len)
		return (0);
	len--;
	while ((input[len] == ' ' || input[len] == '\t') && len > 0)
		len--;
	if (input[len] == '|')
		return (1);
	i = 0;
	while (input[i] == ' ' || input[i] == '\t')
		i++;
	if (input[i] == '|')
		return (1);
	return (0);
}

static int pipe_in_quotes(char *input, int i, int quotes, int j)
{
    while (input[i])
	{
		if (input[i] == '\"' || input[i] == '\'')
		{
			if (quotes == 0)
				quotes = input[i];
			else if (!quotes)
				quotes = 0;
			i++;
			continue ;
		}
		if (input[i] == '|' && !quotes)
		{
			j = i + 1;
			while (input[j] == ' ' || input[j] == '\t')
				j++;
			if (input[j] == '\0' || input[j] == '|')
				return (0);
		}
		i++;
	}
	return (1);
}

static int	check_input_helper(char *input, int in_quote, int in_dquote, int i)
{
	while (input[i])
	{
		if (input[i] == '\'')
		{
			if (in_quote)
				in_quote = 0;
			else if (!in_dquote)
				in_quote = 1;
		}
		else if (input[i] == '\"')
		{
			if (in_dquote)
				in_dquote = 0;
			else if (!in_quote)
				in_dquote = 1;
		}
		i++;
	}
	if (in_quote || in_dquote)
		return (0);
	return (1);
}

static int	check_input(char *input)
{
	int	i;
	int	in_quote;
	int	in_d_quote;

	i = 0;
	in_quote = 0;
	in_d_quote = 0;
	if (!check_input_helper(input, in_quote, in_d_quote, i))
		return (0);
	return (1);
}

int	handle_pipes(t_shell *pipe, char *input, t_cmds *cmds)
{
	int	i;
	int	j;
	int	quotes;

	(void)cmds;
	quotes = 0;
	i = 0;
	j = 0;
	if (pipe_from_back(input))
		return (0);
	if (!pipe_in_quotes(input, i, quotes, j))
		return (0);
	if (!check_input(input))
		return (0);
	pipe->cmds = ft_split(input, '|');
	i = 0;
	while (pipe->cmds[i])
	{
		pipe->cmds[i] = ft_add_spaces(pipe->cmds[i]);
		replace_spaces_tabs(pipe->cmds[i]);
		i++;
		expand()
	}
	pipe->cmd_len = i;
	return (1);
}
==> parsing/redirect.c <==
#include "../minishell.h"

static int	is_redirect(char **input, t_variables *v)
{
	if ((*input)[v->i] == '>' || (*input)[v->i] == '<')
	{
		v->i++;
		if (((*input)[v->i] == '<' && (*input)[v->i - 1] == '<') || \
((*input)[v->i] == '>' && (*input)[v->i - 1] == '>'))
			v->i++;
		while ((*input)[v->i] == ' ' || (*input)[v->i] == '\t')
			v->i++;
		if (((*input)[v->i] == '>' || (*input)[v->i] == '<') \
&& (!v->in_quotes))
			return (0);
		while ((*input)[v->i] == ' ' || (*input)[v->i] == '\t')
			v->i++;
		if ((*input)[v->i] == '\0' || ((*input)[v->i] == '|' && !v->in_quotes))
			return (0);
	}
	else
		v->i++;
	return (1);
}

static int	check_last(char *input)
{
	int	i;

	i = ft_strlen(input);
	if (i)
		i--;
	while (is_spacee(input[i]) && i > 0)
		i--;
	if (input[i] == '>' || input[i] == '<')
		return (0);
	return (1);
}

static int	handle_redirections(char **str, t_variables *vars)
{
	if (!check_last(*str))
		return (0);
	vars->i = 0;
	while ((*str)[vars->i])
	{
		if ((*str)[vars->i] == '\'' || (*str)[vars->i] == '\"')
		{
			if (!vars->in_quotes)
				vars->in_quotes = (*str)[vars->i];
			else if (vars->in_quotes == (*str)[vars->i])
				vars->in_quotes = 0;
		}
		if (!is_redirect(str, vars))
			return (0);
	}
	return (1);
}

int	redirections_parse(char *str)
{
	t_variables	v;

	v.i = 0;
	v.j = 0;
	v.in_d_quotes = 0;
	v.in_quotes = 0;
	if (!handle_redirections(&str, &v))
		return (0);
	return (1);
}

==> parsing/signals.c <==
#include "../minishell.h"

void	handle_signals(int signal)
{
	if (signal == SIGINT)
	{
		write(1, "\n", 1);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
}

==> parsing/spaces_parsing.c <==
#include "../minishell.h"

static void	add_space(int *j, char **new_str, int type)
{
	(*new_str)[(*j)++] = ' ';
	if (type == 0)
		(*new_str)[(*j)++] = '<';
	else if (type == 1)
	{
		(*new_str)[(*j)++] = '<';
		(*new_str)[(*j)++] = '<';
	}
	else if (type == 2)
		(*new_str)[(*j)++] = '>';
	else if (type == 3)
	{
		(*new_str)[(*j)++] = '>';
		(*new_str)[(*j)++] = '>';
	}
	else if (type == 4)
		(*new_str)[(*j)++] = ' ';
	(*new_str)[(*j)++] = ' ';
}

static void	add_spaces_helper(char **input, int *i, int *j, char **new_input)
{
	char	c;
	char	next;

	c = (*input)[*i];
	next = (*input)[*i + 1];
	if (c == '<' && next != '<')
		add_space(j, new_input, 0);
	else if (c == '<' && next == '<')
	{
		(*i)++;
		add_space(j, new_input, 1);
	}
	else if (c == '>' && c != '>')
		add_space(j, new_input, 2);
	else if (c == '>' && next == '>')
	{
		(*i)++;
		add_space(j, new_input, 3);
	}
	else if (c == '\t')
		add_space(j, new_input, 4);
	else
		(*new_input)[(*j)++] = c;
}

char	*ft_add_spaces(char *input)
{
	char	*new_input;
	int		i;
	int		j;
	int		single_q;
	int		double_q;

	i = -1;
	j = 0;
	single_q = 0;
	double_q = 0;
	new_input = malloc(ft_strlen(input) * 3 + 2);
	while (input[++i])
	{
		if (input[i] == '\'' && double_q == 0)
			single_q = !single_q;
		else if (input[i] == '\"' && single_q == 0)
			double_q = !double_q;
		if (!single_q && !double_q)
			add_spaces_helper(&input, &i, &j, &new_input);
		else
			new_input[j++] = input[i];
	}
	new_input[j] = '\0';
	free(input);
	return (new_input);
}

==> parsing/utils.c <==
#include "../minishell.h"

int	spaces(char *str)
{
	int	i;

	i = 0;
	while (str[i] && (str[i] == ' ' || str[i] == '\t'))
		i++;
	if (str[i] == '\0')
		return (1);
	return (0);
}

int	is_spacee(int c)
{
	return (c == ' ' || c == '\t' || c == '\n');
}

static void	increment(char *str, t_variables *vars)
{
	if (str[vars->i] == ' ')
	{
		if (!vars->space_found)
		{
			str[vars->j++] = ' ';
			vars->space_found = 1;
		}
	}
	else
	{
		str[vars->j++] = str[vars->i];
		vars->space_found = 0;
	}
}

void	replace_spaces_tabs(char *str)
{
	t_variables	vars;

	vars.i = 0;
	vars.j = 0;
	vars.space_found = 0;
	vars.quote_char = 0;
	while (str[vars.i] != '\0')
	{
		if (str[vars.i] == '"' || str[vars.i] == '\'')
		{
			if (vars.quote_char == 0)
				vars.quote_char = str[vars.i];
			else if (vars.quote_char == str[vars.i])
				vars.quote_char = 0;
			vars.space_found = 0;
			str[vars.j++] = str[vars.i];
		}
		else if (vars.quote_char == 0)
			increment(str, &vars);
		else
			str[vars.j++] = str[vars.i];
		vars.i++;
	}
	str[vars.j] = '\0';
}

void	clean_quotes(char *str)
{
	int	i;
	int	j;
	int	quote;

	j = 0;
	i = 0;
	quote = 0;
	while (str[i])
	{
		if (str[i] == '\'' || str[i] == '\"')
		{
			if (!quote)
				quote = str[i];
			else if (quote == str[i])
				quote = 0;
			else
				str[j++] = str[i];
		}
		else
			str[j++] = str[i];
		i++;
	}
	str[j] = '\0';
}

==> parsing/utils2.c <==
#include "../minishell.h"

void	quotes_check(char **str, t_variables *v)
{
	if ((*str)[v->i] == '\"')
	{
		if (!v->in_d_quotes)
			v->in_d_quotes = 1;
		else if (v->in_d_quotes)
			v->in_d_quotes = 0;
	}
	if ((*str)[v->i] == '\'' && !v->in_d_quotes)
	{
		if (!v->in_quotes)
			v->in_quotes = 1;
		else if (v->in_quotes)
			v->in_quotes = 0;
	}
}

int	num_of_redirects(char *str)
{
	int			i;
	int			num;
	t_variables	v;

	i = 0;
	num = 0;
	v.i = 0;
	v.in_quotes = 0;
	v.in_d_quotes = 0;
	while (str[i])
	{
		quotes_check(&str, &v);
		if (!v.in_quotes && !v.in_d_quotes && (str[i] == '>' || str[i] == '<'))
		{
			if (str[i + 1] == '>' || str[i + 1] == '<')
				i++;
			num++;
		}
		i++;
		v.i = i;
	}
	return (num);
}

==> free_all.c <==
#include "minishell.h"

void	free_strings(char **av)
{
	int	i;

	i = 0;
	while (av[i])
	{
		free(av[i]);
		i++;
	}
	free(av);
}

void	free_all(t_shell *pipe, t_cmds *cmd)
{
	int	i;
	int	j;

	i = -1;
	j = -1;
	while (++i < pipe->cmd_len)
	{
		j = -1;
		if (cmd[i].red_len > 0)
		{
			while (++j < cmd[i].red_len)
			{
				if (cmd[i].outs[j].file_name)
					free(cmd[i].outs[j].file_name);
			}
			if (cmd[i].outs)
				free(cmd[i].outs);
		}
		free_strings(cmd[i].cmds);
	}
	free_strings(pipe->cmds);
	free(cmd);
}

==> minishell.c <==
#include "minishell.h"

int	main(int ac, char **av, char **env)
{
	char		*input;
	t_shell		s;
	t_cmds		*cmd;

	(void)av;
	if (ac != 1)
		return (0);
	copy_env(&s, env);
	while (1)
	{
		signal(SIGINT, handle_signals);
		signal(SIGQUIT, SIG_IGN);
		input = readline("minishell> ");
		if (!input)
			return (printf("exit\n"), 0);
		if (parsing(&s, cmd, input))
			continue ;
		init_commands(&s, &cmd);
		free_all(&s, cmd);
		add_history(input);
	}
	return (0);
}

==> minishell.h <==
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include "libft/libft.h"
# include <errno.h>
# include <limits.h>
# include <pthread.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <stdbool.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/time.h>
# include <time.h>
# include <unistd.h>

extern int	g_exit_code;

enum e_types
{
	IN_FILE,
	OUT_FILE,
	APPEND,
	HERE_DOC,
};

typedef struct s_redirect
{
	int		flag;
	char	*file_name;
}	t_redirect;

typedef struct s_cmds
{
	int			red_len;
	int			cmd_len;
	char		**cmds;
	t_redirect	*outs;
}	t_cmds;

typedef struct s_variables
{
	int	i;
	int	j;
	int	cmd_i;
	int	arg_i;
	int	space_found;
	int	quote_char;
	int	char_i;
	int	start;
	int	len;
	int	xy;
	int	in_d_quotes;
	int	in_quotes;
}	t_variables;

typedef struct s_shell
{
	int		cmd_len;
	int		num_cmd;
	t_list	*environment;
	int		environment_num;
	char	**cmds;
}	t_shell;

//           environment              \\.
int		parsing(t_shell *pipe, t_cmds *cmds, char *input);
void	copy_env(t_shell *s, char **env);
char	*ft_add_spaces(char *input);
void	replace_spaces_tabs(char *str);
char	*my_getenv(const char *name, t_shell *pipe);
void	clean_quotes(char *str);

//            utils             \\.
int		spaces(char *str);
int		is_spacee(int c);
void	free_all(t_shell *pipe, t_cmds *cmd);
void	free_strings(char **av);
void	remove_substr(char *s, unsigned int start, size_t len);

//            signals            \\.
void	handle_signals(int signal);

//            redirect           \\.
int		redirections_parse(char *str);
int		num_of_redirects(char *str);

//             pipes             \\.
int		handle_pipes(t_shell *pipe, char *input, t_cmds *cmds);

//             cmds              \\.
void	init_commands(t_shell *pipe, t_cmds **tmp);

void	rl_replace_line(const char *text, int clear_undo);
void	rl_redisplay(void);
void	quotes_check(char **str, t_variables *v);

#endif